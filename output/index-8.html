<!DOCTYPE html>
<html prefix="
og: http://ogp.me/ns#
article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is Pengyin Shan's Note">
<meta name="viewport" content="width=device-width">
<title>Pengyin's Note (old posts, page 8) | Pengyin's Note</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="http://pengyin-shan.com/index-8.html">
<!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]--><style>
    div.input_prompt {
      display: none;
    }
    </style>
</head>
<body>
    <section class="social"><ul>
<li><a href="index.html" title="Home"><i class="icon-home"></i></a></li>
            <li><a href="archive.html" title="Archives"><i class="icon-folder-open-alt"></i></a></li>
            <li><a href="categories/index.html" title="Tags"><i class="icon-tags"></i></a></li>
            <li><a href="rss.xml" title="RSS"><i class="icon-rss"></i></a></li>
            <li><a href="https://www.linkedin.com/in/pengyinshan" title="My LinkedIn"><i class="icon-linkedin"></i></a></li>
            <li><a href="https://github.com/shanpy" title="My Github"><i class="icon-github"></i></a></li>

        </ul></section><section class="page-content"><div class="content" rel="main">
        <div class="post">
            <h1 class="title"><a href="posts/2015/JavaScript/number-precision-in-javascript.html">Number Precision in JavaScript</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2015-09-22T00:00:00-04:00">2015-09-22 00:00</time>
</div>
                <div class="stats">
                                <a href="posts/2015/JavaScript/number-precision-in-javascript.html#disqus_thread" data-disqus-identifier="cache/posts/2015/JavaScript/number-precision-in-javascript.html">Comments</a>


                </div>
                    <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/javascript.html" rel="tag">JavaScript</a></li>
        </ul>
</div>

            </div>
            <div class="body">
                <div>
<p>Following methods is referenced from developer.mozilla.org.</p>
<h4>Number.prototype.toPrecision()</h4>
<p>The <code>toPrecision()</code> method returns a string representing the Number object to the specified precision.</p>
<p>Example:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">test</span> <span class="o">=</span> <span class="mf">1.999</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">()</span> <span class="c1">//1.999</span>

<span class="kd">var</span> <span class="nx">test2</span> <span class="o">=</span> <span class="mf">1.511</span>
<span class="nx">test2</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//2</span>
<span class="nx">test2</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//1.5</span>

<span class="kd">var</span> <span class="nx">test3</span> <span class="o">=</span> <span class="mf">1.001</span>
<span class="nx">test3</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//1</span>
<span class="nx">test3</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//1.0</span>

<span class="kd">var</span> <span class="nx">test4</span> <span class="o">=</span> <span class="mf">0.999</span>
<span class="nx">test4</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//1</span>
<span class="nx">test4</span><span class="p">.</span><span class="nx">toPrecision</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//1.0</span>
</pre>


<h4>Number.prototype.toFixed()</h4>
<p>The <code>toFixed(parameter)</code> method formats a number using <strong>fixed-point notation</strong>.</p>
<p><em>The parameter may be a value between 0 and 20, inclusive. If no parameter, it is treated as 0.</em></p>
<p>This function returns a string representation of the number that <strong>does not use exponential notation and has exactly digits digits after the decimal place</strong>. The number is <strong>rounded</strong> if necessary, and the fractional part is <strong>padded with zeros</strong> if necessary so that it has the specified length.</p>
<p>Example:</p>
<pre class="code literal-block"><span></span><span class="nx">test</span> <span class="o">=</span> <span class="mf">2.059</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">()</span> <span class="c1">//2</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//2.1</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//2.06</span>

<span class="nx">test2</span> <span class="o">=</span> <span class="mi">2</span><span class="nx">e</span><span class="o">+</span><span class="mi">10</span>
<span class="nx">test2</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//20000000000.0</span>
</pre>


<blockquote>
<p>toPrecision() is to count the total length. toFixed() is to count length after decimal point.</p>
</blockquote>
<h4>Number.prototype.toExponential()</h4>
<p>The <code>toExponential(parameter)</code> method returns a string representing the Number object in <strong>exponential notation</strong>.</p>
<p><em>The parameter specifying the number of digits after the decimal point.</em></p>
<p><em>If you use the `toExponential()`` method for a numeric literal and the numeric literal has no exponent and no decimal point, <strong>leave a space before the dot</strong> that precedes the method call to prevent the dot from being interpreted as a decimal point.</em></p>
<p>Example:</p>
<pre class="code literal-block"><span></span><span class="nx">test</span> <span class="o">=</span> <span class="mf">2.019</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">toExponential</span><span class="p">()</span> <span class="c1">//'2.019e+0'</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">toExponential</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">//'2.0e+0'</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">toExponential</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//'2.02e+0'</span>
</pre>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/2015/Algorithm%20Data%20Structure/algorithm-and-data-structure-basics-sorting.html">Algorithm and Data Structure Basics - Sorting</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2015-09-11T00:00:00-04:00">2015-09-11 00:00</time>
</div>
                <div class="stats">
                                <a href="posts/2015/Algorithm%20Data%20Structure/algorithm-and-data-structure-basics-sorting.html#disqus_thread" data-disqus-identifier="cache/posts/2015/Algorithm Data Structure/algorithm-and-data-structure-basics-sorting.html">Comments</a>


                </div>
                    <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/algorithm.html" rel="tag">Algorithm</a></li>
           <li><a class="tag p-category" href="categories/data-structure.html" rel="tag">Data Structure</a></li>
           <li><a class="tag p-category" href="categories/java.html" rel="tag">Java</a></li>
           <li><a class="tag p-category" href="categories/sorting.html" rel="tag">Sorting</a></li>
        </ul>
</div>

            </div>
            <div class="body">
                <div>
<h4>Reference List</h4>
<ul>
<li>
<p><strong>Introduction to Algorithms (Third Edition/Chinese Version)</strong>, written by <em>Thomas H.Cormen</em>, <em>Charles E.Leiserson</em>, <em>Ronald L.Rivest</em> and <em>Clifford Stein</em>, and translated by <em>Jianping Yin</em>, <em>Yun Xu</em>, <em>Gang Wang</em>, <em>Xiaoguang Liu</em>, <em>Ming Su</em>, <em>Hengming Zou</em> and <em>HongZhi Wang</em>.</p>
</li>
<li>
<p><strong>Data Structures and Algorithms in Java (Second Edition/Chinese Version)</strong>, written by <em>Robert Lafore</em>, and translated by <em>Xiaoyun Ji</em>, <em>Yan Zhao</em>, <em>Xi Zeng</em> and <em>Xiaohan Di</em>.</p>
</li>
</ul>
<h4>Terminology &amp; Runtime Analysis</h4>
<p><em>This part serves as a reading note for Introduction to Algorithms (Third Edition), Chapter 1 and Chapter 2, to clarify some basic terms of Algorithms</em>.</p>
<p><code>Algorithm</code> is the process of reading a value or a collection of value as <strong>input</strong>, and product a value or a collection of value as <strong>output</strong>.</p>
<p>A sequence of input (with constrains) from a algorithm question is called a <code>instance</code> of that question.</p>
<h5>Runtime Analysis</h5>
<p>From the book <em>Introduction to Algorithms</em>, the reason we are focusing on <strong>worst case running time</strong> is:</p>
<ol>
<li>
<p>The worst running time gives a upper limitation running time for any input.</p>
</li>
<li>
<p>For some special algorithms, users can easily get worst case, such as searching for record which may not exist in database.</p>
</li>
<li>
<p>There is lots of times that the <em>average running time</em> is the same as the <em>worst running time</em>.</p>
</li>
</ol>
<h4>Basic Insertion Sort, with Analysis for Algorithm Questions</h4>
<p>Insertion sort is very useful for a <strong>small</strong> amount of input.</p>
<p>In book <em>Introduction to Algorithms</em>, insertion sort is described as the same process of someone sorting a group of pokers in a poker game. All elements on one side of your current item (i.e. the item that is supposed to be sorted) is in order.</p>
<p>Pseudo-code for Insertion Sort:</p>
<pre class="code literal-block"><span></span>/*
* In following code<span class="p">,</span> <span class="k">left</span> side of <span class="nb">key</span> <span class="k">is</span> always being sorted<span class="p">,</span> <span class="k">in</span> acceding order.
* In comparing process<span class="p">,</span> starting from the element <span class="k">on</span> the <span class="k">left</span> of <span class="nb">key</span><span class="p">,</span> then moving towards <span class="k">start</span> of array.
*/
<span class="k">for</span> <span class="k">j</span><span class="p">=</span><span class="m">2</span> <span class="k">to</span> A.length
    <span class="nb">key</span> <span class="p">=</span> A[<span class="k">j</span>]
    <span class="k">i</span> <span class="p">=</span> <span class="k">j</span><span class="m">-1</span>

    <span class="sr">//</span>This loops means <span class="k">all</span> sorted elements begin <span class="k">to</span> move one space <span class="k">to</span> <span class="k">end</span> of array<span class="p">,</span> <span class="k">so</span> that <span class="nb">key</span> can be inserted <span class="k">to</span> gap
    <span class="k">while</span> <span class="k">i</span><span class="p">&gt;</span><span class="m">0</span> and A[<span class="k">i</span>] <span class="p">&gt;</span> <span class="nb">key</span>
        A[<span class="k">i</span><span class="p">+</span><span class="m">1</span>] <span class="p">=</span> A[<span class="k">i</span>]
        <span class="k">i</span> <span class="p">=</span> <span class="k">i</span><span class="m">-1</span>
    A[<span class="k">i</span><span class="p">+</span><span class="m">1</span>] <span class="p">=</span> <span class="nb">key</span>
</pre>


<h4>Basic Selection Sort</h4>
<p>To perform selection sort, you are given a array of numbers: <code>A</code>.</p>
<ol>
<li>
<p>You find the smallest element in A, then exchange this element with the element in A[0]</p>
</li>
<li>
<p>Starting from A[1], find the smallest element then changing with A[1]</p>
</li>
<li>
<p>Continue this process until you reach A[A.length-1]</p>
</li>
</ol>
<p>Code in Java:</p>
<pre class="code literal-block"><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">selectionSort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">out</span><span class="o">,</span> <span class="n">in</span><span class="o">,</span> <span class="n">min</span><span class="o">;</span>

    <span class="k">for</span><span class="o">(</span><span class="n">out</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">out</span><span class="o">&lt;</span><span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">out</span><span class="o">++){</span>
        <span class="n">min</span> <span class="o">=</span> <span class="n">A</span><span class="o">[</span><span class="n">out</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="n">in</span><span class="o">=</span><span class="n">out</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">in</span><span class="o">&lt;</span><span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">in</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">in</span><span class="o">]&lt;</span><span class="n">min</span><span class="o">)</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">in</span><span class="o">];</span>
            <span class="n">swap</span><span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">out</span><span class="o">],</span> <span class="n">min</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>


<h4>Basic Merge Sort</h4>
<p>Merge sort uses <code>divide-and-concur</code> mode:</p>
<ol>
<li>
<p>Divide original question to smaller questions. For each sub-question, it is a instance of original question.</p>
</li>
<li>
<p>Solution these sub-questions by using <code>recursion</code>. When the sub-question is small enough, solve this sub-question.</p>
</li>
<li>
<p>Concur/Merge these sub-solutions to the solution of original question.</p>
</li>
</ol>
<p>The process of merge sort is:</p>
<ol>
<li>
<p>Divide the array of <code>n</code> elements to two sub-array. Each sub-array should have <code>n/2</code> elements.</p>
</li>
<li>
<p>Recursively repeating the first step to sub-arrays until each sub-array only have one element (i.e. Being sorted already).</p>
</li>
<li>
<p>Merge all sorted arrays to one sorted array.</p>
</li>
</ol>
<p>The merge process is the key part of merge sort. From <em>Introduction to Algorithms</em>, A function <code>merge(A, p, q, r)</code> can be used to perform merge process, where <code>A</code> is the array, and <code>p &lt;= q &lt;= r</code>. This process assumes that <code>A[p:q]</code> and <code>A[q+1:r]</code> has been sorted. At the end of merge process, <code>A[p:r]</code> should be sorted.</p>
<p>In <em>Introduction to Algorithms</em>, a <strong>poker example</strong> is used to describe the merge process. The merge process is to chose a smaller one from the top of two piled poker, and put that poker to a new pile. Repeat this process until one pile is empty.</p>
<p>Since we most perform <code>n</code> steps to merge, the running time of merge is $theta (n)$.</p>
<p>For Merge Sort in Java, please refer to <a href="posts/2015/Algorithm%20Data%20Structure/blog/algorithm-and-data-structure-basics-recursion">this post</a>.</p>
<h4>Tips and Comments</h4>
<ul>
<li>From <em>Introduction to Algorithms</em>, if you have a binary number, moving all digits one position to left means multiplying it by two. if you move all digits <em>k</em> position to left, you multiply origin number by $2^k$.</li>
</ul>
<p>Other parts are working in process :)</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/2015/Algorithm%20Data%20Structure/algorithm-and-data-structure-basics-heap.html">Algorithm and Data Structure Basics - Heap</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2015-09-03T00:00:00-04:00">2015-09-03 00:00</time>
</div>
                <div class="stats">
                                <a href="posts/2015/Algorithm%20Data%20Structure/algorithm-and-data-structure-basics-heap.html#disqus_thread" data-disqus-identifier="cache/posts/2015/Algorithm Data Structure/algorithm-and-data-structure-basics-heap.html">Comments</a>


                </div>
                    <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/algorithm.html" rel="tag">Algorithm</a></li>
           <li><a class="tag p-category" href="categories/data-structure.html" rel="tag">Data Structure</a></li>
           <li><a class="tag p-category" href="categories/heap.html" rel="tag">Heap</a></li>
           <li><a class="tag p-category" href="categories/java.html" rel="tag">Java</a></li>
        </ul>
</div>

            </div>
            <div class="body">
                <div>
<h4>Reference List</h4>
<ul>
<li>
<em>Data Structures and Algorithms in Java (Second Edition)</em>, written by <em>Robert Lafore</em>, Chinese Version</li>
</ul>
<h4>Basic Information</h4>
<p>Heap is a type of tree. If you create a <strong>priority queue</strong> from heap. The time complexity for insertion and deletion is <code>O(logN)</code>. However, heap doesn't support traversal and search by value, because all path in heap is following descending/ascending order.</p>
<p>Heap has following features:</p>
<ul>
<li>
<p>It is a <strong>complete binary tree</strong>. A complete binary tree means every layer except leaf layer has full nodes.</p>
</li>
<li>
<p>Heap is normally implemented by a array</p>
</li>
<li>
<p>For each node in heap, the value of this node is larger or equal to the value of its child nodes (Maximum Heap). If current node is smaller or equal to its child nodes, the heap is Minimum Heap.</p>
</li>
</ul>
<p>Following is the graph for array implementation of heap, taken from <em>Data Structures and Algorithms in Java (Second Edition)</em>:</p>
<p>{% img ../images/articles/2015/algorithm/heap_array.PNG %}</p>
<blockquote>
<p>As you can see, if the index of a random element in array is <code>x</code>, then the index of its parent node is <code>(x-1)/2</code>. The index of its left child node is <code>2*x+1</code>. The index of its right child node is <code>2*x+2</code></p>
</blockquote>
<p><em>In Java, <code>/</code> will get floor integer value</em>.</p>
<blockquote>
<p>All nodes which have index larger than <code>n/2</code> are leaf nodes, assuming there are n elements in array.</p>
</blockquote>
<h4>Remove</h4>
<p>In heap, remove means removing the root of the heap. This root is always the largest/smallest value of all elements. For the heap array, root always has index <code>0</code>.</p>
<p>You need two steps to find removing process:</p>
<ol>
<li>
<p>Take root of heap out</p>
</li>
<li>
<p>Fill the root hold by move the last element to root, then reverse and change nodes until heap is correct.</p>
</li>
</ol>
<p>Detail of steps:</p>
<ol>
<li>
<p>Remove root by using <code>max = heapArray[o];</code></p>
</li>
<li>
<p>Move last element to root by using <code>heapArray[0] = heapArray[N-1]; N--;</code></p>
</li>
<li>
<p>Move this new root to bottom, until it's smaller than its parent node and larger than its child nodes. To do this, check if root is smaller than it's <strong>larger child</strong>. If so, swap root and its larger child. Repeat this.</p>
</li>
</ol>
<h5>Code</h5>
<pre class="code literal-block"><span></span><span class="c1">//We assume each node has a attribute 'key', which determine the value/priority of this node</span>
<span class="kd">public</span> <span class="n">Node</span> <span class="nf">remove</span><span class="o">(){</span>
    <span class="n">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="n">heapArray</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="n">heapArray</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">heapArray</span><span class="o">[--</span><span class="n">currentSize</span><span class="o">];</span> <span class="c1">//Move last element to root position</span>
    <span class="n">trickleDown</span><span class="o">[</span><span class="n">o</span><span class="o">];</span> <span class="c1">//trickleDown new root</span>
    <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">trackleDown</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">largetChild</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">heapArray</span><span class="o">[</span><span class="n">index</span><span class="o">];</span> <span class="c1">//current Node</span>

    <span class="c1">//while index is not on leaf node</span>
    <span class="k">while</span><span class="o">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">currentSize</span><span class="o">/</span><span class="mi">2</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">leftChild</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">rightChild</span> <span class="o">=</span> <span class="n">leftChild</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">//Get larger child</span>
        <span class="k">if</span><span class="o">(</span><span class="n">rightChild</span> <span class="o">&lt;</span> <span class="n">currentSize</span> <span class="o">&amp;&amp;</span> <span class="n">heapArray</span><span class="o">[</span><span class="n">leftChild</span><span class="o">].</span><span class="na">getKey</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">heapArray</span><span class="o">[</span><span class="n">rightChild</span><span class="o">].</span><span class="na">getKey</span><span class="o">()){</span>
            <span class="n">largerChild</span> <span class="o">=</span> <span class="n">rightChild</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span>
            <span class="n">largerChild</span> <span class="o">=</span> <span class="n">leftChild</span><span class="o">;</span>

        <span class="c1">//Break while loop when current value is larger than larger child value</span>
        <span class="k">if</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">getKey</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">heapArray</span><span class="o">[</span><span class="n">largerChild</span><span class="o">].</span><span class="na">getKey</span><span class="o">())</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="cm">/*</span>
<span class="cm">        If not break loop, move child to current position.</span>
<span class="cm">        Go to another loop starting from larger child position.</span>
<span class="cm">        current keeps the same</span>
<span class="cm">        */</span>
        <span class="n">heapArray</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">heapArray</span><span class="o">[</span><span class="n">largerChild</span><span class="o">];</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">largerChild</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">heapArray</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span> <span class="c1">//After loop, assign new root to proper position</span>
<span class="o">}</span>
</pre>


<h4>Insert</h4>
<p>Insertion can by down by following step:</p>
<ol>
<li>
<p>Put the new element to end of array(i.e. end of heap): <code>heapArray[N] = insertNode; N++;</code></p>
</li>
<li>
<p>Recursively moving this node so that it will be larger than its child elements and smaller than its parent node. i.e. if node is smaller larger than its parent node, swap this node and its parent node.</p>
</li>
</ol>
<h5>Code</h5>
<pre class="code literal-block"><span></span><span class="c1">//We assume each node has a attribute 'key', which determine the value/priority of this node</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span> <span class="n">key</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">currentSize</span> <span class="o">==</span> <span class="n">maxSize</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">//no more room for insertion</span>
    <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="n">heapArray</span><span class="o">[</span><span class="n">currentSize</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="n">currentSize</span><span class="o">++;</span>
    <span class="n">trickleUp</span><span class="o">(</span><span class="n">currentSize</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">trickleUp</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">){</span>
    <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="o">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span> <span class="c1">//get parent index</span>
    <span class="n">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">heapArray</span><span class="o">[</span><span class="n">index</span><span class="o">];</span> <span class="c1">//get current node</span>

    <span class="k">while</span><span class="o">(</span><span class="n">index</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">heapArray</span><span class="o">[</span><span class="n">parent</span><span class="o">].</span><span class="na">getKey</span><span class="o">()&lt;</span><span class="n">bottom</span><span class="o">.</span><span class="na">getKey</span><span class="o">()){</span>
        <span class="n">heapArray</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">heapArray</span><span class="o">[</span><span class="n">parent</span><span class="o">];</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">parent</span><span class="o">;</span> <span class="c1">//Now parent index should be current index</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="o">(</span><span class="n">parent</span><span class="o">-</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span> <span class="c1">//Get new parent index</span>
    <span class="o">}</span>

    <span class="n">heapArray</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span> <span class="c1">//after while loop, assign current node to final place</span>
<span class="o">}</span>
</pre>


<h4>Change Value</h4>
<p>Working in process...</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/2015/Algorithm%20Data%20Structure/algorithm-and-data-structure-basics-recursion.html">Algorithm and Data Structure Basics - Recursion</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2015-09-02T00:00:00-04:00">2015-09-02 00:00</time>
</div>
                <div class="stats">
                                <a href="posts/2015/Algorithm%20Data%20Structure/algorithm-and-data-structure-basics-recursion.html#disqus_thread" data-disqus-identifier="cache/posts/2015/Algorithm Data Structure/algorithm-and-data-structure-basics-recursion.html">Comments</a>


                </div>
                    <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/algorithm.html" rel="tag">Algorithm</a></li>
           <li><a class="tag p-category" href="categories/data-structure.html" rel="tag">Data Structure</a></li>
           <li><a class="tag p-category" href="categories/java.html" rel="tag">Java</a></li>
           <li><a class="tag p-category" href="categories/recursion.html" rel="tag">Recursion</a></li>
        </ul>
</div>

            </div>
            <div class="body">
                <div>
<h4>Reference List</h4>
<ul>
<li>
<p><a href="http://www.nowamagic.net/librarys/veda/detail/2314">Understand Recursion (Chinese)</a></p>
</li>
<li>
<p><a href="http://blog.csdn.net/wangjinyu501/article/details/8248492">Recursion (Chinese)</a></p>
</li>
</ul>
<h4>Common Model of Recursion</h4>
<pre class="code literal-block"><span></span><span class="n">Obj</span> <span class="nf">recursion</span><span class="o">(</span><span class="n">Obj</span> <span class="n">o</span><span class="o">){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">baseCondition</span><span class="o">){</span>
        <span class="cm">/*</span>
<span class="cm">        You need to return here, so that recursion part can use the basic value which is returned back</span>
<span class="cm">        */</span>
        <span class="k">return</span> <span class="n">baseConditionResult</span><span class="o">;</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">some_expression</span><span class="o">;</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>


<p><em>If there are other expression before or after recursion call, make sure you run it after each call back, because these expressions are part of method, and you want to call the full method for each recursion. Check "Hanoi" example below for detail.</em></p>
<h4>Problem in Recursion</h4>
<p>Since system using <strong>stack</strong> to save return values from each callback, it's really easy to get memory overflow problem.</p>
<h4>Hanoi</h4>
<h5>Rule</h5>
<ol>
<li>
<p>Move plate when number of plate is <code>1</code> (In code below, we want to printout basic value);</p>
</li>
<li>
<p>If number of plates on a tower is more than <code>1</code> (assume <code>n</code>), move first <code>n-1</code> plate, then move the bottom plate.</p>
</li>
</ol>
<h5>Code</h5>
<pre class="code literal-block"><span></span><span class="cm">/**</span>
<span class="cm">Result:</span>
<span class="cm">    Dist 1 from A  to C</span>
<span class="cm">    Dist 2 from A to B</span>
<span class="cm">    Dist 1 from C  to B</span>
<span class="cm">    Dist 3 from A to C</span>
<span class="cm">    Dist 1 from B  to A</span>
<span class="cm">    Dist 2 from B to C</span>
<span class="cm">    Dist 1 from A  to C</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hanoi</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">nDisks</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doTowers</span><span class="o">(</span><span class="kt">int</span> <span class="n">topN</span><span class="o">,</span> <span class="kt">char</span> <span class="n">from</span><span class="o">,</span> <span class="kt">char</span> <span class="n">inter</span><span class="o">,</span> <span class="kt">char</span> <span class="n">to</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">topN</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dist "</span> <span class="o">+</span> <span class="n">topN</span> <span class="o">+</span> <span class="s">" from "</span> <span class="o">+</span> <span class="n">from</span> <span class="o">+</span> <span class="s">" to "</span> <span class="o">+</span> <span class="n">to</span><span class="o">);</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="c1">//Move top n-1 from start tower to mid tower</span>
            <span class="n">doTowers</span><span class="o">(</span><span class="n">topN</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">,</span> <span class="n">inter</span><span class="o">);</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dist "</span> <span class="o">+</span> <span class="n">topN</span> <span class="o">+</span> <span class="s">" from "</span> <span class="o">+</span> <span class="n">from</span> <span class="o">+</span> <span class="s">" to "</span> <span class="o">+</span> <span class="n">to</span><span class="o">);</span>
            <span class="c1">//Move top n-1 from mid tower to end tower</span>
            <span class="n">doTowers</span><span class="o">(</span><span class="n">topN</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">inter</span><span class="o">,</span> <span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">doTowers</span><span class="o">(</span><span class="n">nDisks</span><span class="o">,</span> <span class="sc">'A'</span><span class="o">,</span> <span class="sc">'B'</span><span class="o">,</span> <span class="sc">'C'</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre>


<p>To make code looks clear, I draw a draft of the sequence of recursion call for the code above. Note the purpose numbers are the sequence of call:</p>
<p>{% img ../images/articles/2015/algorithm/hanoi_graph.png %}</p>
<h4>Merge Sort</h4>
<h5>Code</h5>
<pre class="code literal-block"><span></span><span class="cm">/*</span>
<span class="cm">Output:</span>
<span class="cm">72 90 45 126 54</span>
<span class="cm">45 54 72 90 126</span>
<span class="cm">*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MergeSort</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">theArray</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">nElems</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MergeSort</span><span class="o">(</span><span class="kt">int</span> <span class="n">max</span><span class="o">){</span>
        <span class="n">theArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">max</span><span class="o">];</span>
        <span class="n">nElems</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">){</span>
        <span class="n">theArray</span><span class="o">[</span><span class="n">nElems</span><span class="o">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">nElems</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">(){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nElems</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">theArray</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mergeSort</span><span class="o">(){</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">workspace</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">nElems</span><span class="o">];</span>
        <span class="n">recMergeSort</span><span class="o">(</span><span class="n">workspace</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nElems</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">recMergeSort</span><span class="o">(</span><span class="kt">long</span><span class="o">[]</span> <span class="n">workspace</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lowerBound</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upperBound</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lowerBound</span> <span class="o">==</span> <span class="n">upperBound</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lowerBound</span> <span class="o">+</span> <span class="n">upperBound</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
            <span class="n">recMergeSort</span><span class="o">(</span><span class="n">workspace</span><span class="o">,</span> <span class="n">lowerBound</span><span class="o">,</span> <span class="n">mid</span><span class="o">);</span>
            <span class="n">recMergeSort</span><span class="o">(</span><span class="n">workspace</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">upperBound</span><span class="o">);</span>
            <span class="n">merge</span><span class="o">(</span><span class="n">workspace</span><span class="o">,</span><span class="n">lowerBound</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">upperBound</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">long</span><span class="o">[]</span> <span class="n">workspace</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lowPtr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">highPtr</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upperBound</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">lowerBound</span> <span class="o">=</span> <span class="n">lowPtr</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">highPtr</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">upperBound</span> <span class="o">-</span> <span class="n">lowerBound</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="c1">//# of items</span>

        <span class="k">while</span><span class="o">(</span><span class="n">lowPtr</span> <span class="o">&lt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">highPtr</span> <span class="o">&lt;=</span> <span class="n">upperBound</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">theArray</span><span class="o">[</span><span class="n">lowPtr</span><span class="o">]&lt;</span><span class="n">theArray</span><span class="o">[</span><span class="n">highPtr</span><span class="o">]){</span>
                <span class="n">workspace</span><span class="o">[</span><span class="n">j</span><span class="o">++]</span> <span class="o">=</span> <span class="n">theArray</span><span class="o">[</span><span class="n">lowPtr</span><span class="o">++];</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="n">workspace</span><span class="o">[</span><span class="n">j</span><span class="o">++]</span> <span class="o">=</span> <span class="n">theArray</span><span class="o">[</span><span class="n">highPtr</span><span class="o">++];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">while</span><span class="o">(</span><span class="n">lowPtr</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">){</span> <span class="c1">//upper side are gone, some lower side left</span>
            <span class="n">workspace</span><span class="o">[</span><span class="n">j</span><span class="o">++]</span> <span class="o">=</span> <span class="n">theArray</span><span class="o">[</span><span class="n">lowPtr</span><span class="o">++];</span>
        <span class="o">}</span>
        <span class="k">while</span><span class="o">(</span><span class="n">highPtr</span><span class="o">&lt;=</span><span class="n">upperBound</span><span class="o">){</span> <span class="c1">//lower side are gone, some upperside left</span>
            <span class="n">workspace</span><span class="o">[</span><span class="n">j</span><span class="o">++]</span> <span class="o">=</span> <span class="n">theArray</span><span class="o">[</span><span class="n">highPtr</span><span class="o">++];</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span><span class="c1">//copy back</span>
            <span class="n">theArray</span><span class="o">[</span><span class="n">lowerBound</span><span class="o">+</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">workspace</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxSize</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
        <span class="n">MergeSort</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MergeSort</span><span class="o">(</span><span class="n">maxSize</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">72</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">90</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">45</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">126</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">54</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">display</span><span class="o">();</span>

        <span class="n">arr</span><span class="o">.</span><span class="na">mergeSort</span><span class="o">();</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">display</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre>


<h4>Binary Search</h4>
<pre class="code literal-block"><span></span><span class="cm">/**</span>
<span class="cm">Output:</span>
<span class="cm">    45 54 72 90 126</span>
<span class="cm">    Found 54</span>
<span class="cm">**/</span>
<span class="kd">class</span> <span class="nc">BinarySearch</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">nElems</span><span class="o">;</span> <span class="c1">//count how many existing elements in array</span>

    <span class="kd">public</span> <span class="nf">BinarySearch</span><span class="o">(</span><span class="kt">int</span> <span class="n">max</span><span class="o">){</span>
        <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">max</span><span class="o">];</span>
        <span class="n">nElems</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">nElems</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">long</span> <span class="n">searchKey</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">recFind</span><span class="o">(</span><span class="n">searchKey</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">nElems</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">recFind</span><span class="o">(</span><span class="kt">long</span> <span class="n">searchKey</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lowerBound</span><span class="o">,</span> <span class="kt">int</span> <span class="n">upperBound</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">curIn</span><span class="o">;</span>

        <span class="n">curIn</span> <span class="o">=</span> <span class="o">(</span><span class="n">lowerBound</span> <span class="o">+</span> <span class="n">upperBound</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">curIn</span><span class="o">]</span> <span class="o">==</span> <span class="n">searchKey</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">curIn</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">lowerBound</span> <span class="o">&gt;</span> <span class="n">upperBound</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">nElems</span><span class="o">;</span> <span class="c1">//cannot find</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">curIn</span><span class="o">]&lt;</span><span class="n">searchKey</span><span class="o">)</span>
                <span class="k">return</span> <span class="n">recFind</span><span class="o">(</span><span class="n">searchKey</span><span class="o">,</span> <span class="n">curIn</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">upperBound</span><span class="o">);</span> <span class="c1">//check larger half</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">recFind</span><span class="o">(</span><span class="n">searchKey</span><span class="o">,</span> <span class="n">lowerBound</span><span class="o">,</span> <span class="n">curIn</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nElems</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]&gt;</span><span class="n">value</span><span class="o">){</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">nElems</span><span class="o">;</span> <span class="n">k</span><span class="o">&gt;</span><span class="n">j</span><span class="o">;</span> <span class="n">k</span><span class="o">--){</span>
            <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">nElems</span> <span class="o">++;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">(){</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nElems</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">maxSize</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
        <span class="n">BinarySearch</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinarySearch</span><span class="o">(</span><span class="n">maxSize</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">72</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">90</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">45</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">126</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">54</span><span class="o">);</span>
        <span class="n">arr</span><span class="o">.</span><span class="na">display</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">searchKey</span> <span class="o">=</span> <span class="mi">54</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">searchKey</span><span class="o">)</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Found "</span> <span class="o">+</span> <span class="n">searchKey</span><span class="o">);</span>
        <span class="k">else</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Can't find "</span> <span class="o">+</span> <span class="n">searchKey</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre>


<h4>Word Recursion (Anagram)</h4>
<h5>Idea</h5>
<p>Assume a word has <code>n</code> letters:</p>
<ol>
<li>
<p>List right-most <code>n-1</code> letters</p>
</li>
<li>
<p>Rotate all <code>n</code> letters</p>
</li>
<li>
<p>Do two steps above <code>n</code> times</p>
</li>
</ol>
<h5>Code</h5>
<pre class="code literal-block"><span></span><span class="cm">/**</span>
<span class="cm">If you input 'test', you will get:</span>
<span class="cm">  1 test</span>
<span class="cm">  2 tets</span>
<span class="cm">  3 tste</span>
<span class="cm">  4 tset</span>
<span class="cm">  5 ttes</span>
<span class="cm">  6 ttse</span>
<span class="cm">  7 estt</span>
<span class="cm">  8 estt</span>
<span class="cm">  9 etts</span>
<span class="cm"> 10 etst</span>
<span class="cm"> 11 etst</span>
<span class="cm"> 12 etts</span>
<span class="cm"> 13 stte</span>
<span class="cm"> 14 stet</span>
<span class="cm"> 15 stet</span>
<span class="cm"> 16 stte</span>
<span class="cm"> 17 sett</span>
<span class="cm"> 18 sett</span>
<span class="cm"> 19 ttes</span>
<span class="cm"> 20 ttse</span>
<span class="cm"> 21 test</span>
<span class="cm"> 22 tets</span>
<span class="cm"> 23 tste</span>
<span class="cm"> 24 tset</span>
<span class="cm">**/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordRecurtion</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">arrChar</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">100</span><span class="o">];</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Enter a word: "</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">getString</span><span class="o">();</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
            <span class="n">arrChar</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">doAnagram</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doAnagram</span><span class="o">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">newSize</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
          <span class="k">return</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">newSize</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
          <span class="n">doAnagram</span><span class="o">(</span><span class="n">newSize</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
          <span class="k">if</span><span class="o">(</span><span class="n">newSize</span><span class="o">==</span><span class="mi">2</span><span class="o">)</span>
            <span class="n">displayWord</span><span class="o">();</span>
          <span class="c1">//Starting from every two words, rotate after each recursion</span>
          <span class="n">rotate</span><span class="o">(</span><span class="n">newSize</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}</span>

      <span class="c1">//Rotate word one position to right</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span> <span class="n">newSize</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">newSize</span><span class="o">;</span>
        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arrChar</span><span class="o">[</span><span class="n">position</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="n">j</span><span class="o">=</span><span class="n">position</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
          <span class="n">arrChar</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arrChar</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">arrChar</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">displayWord</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">&lt;</span><span class="mi">99</span><span class="o">)</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">)</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(++</span><span class="n">count</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span>
          <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">arrChar</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">getString</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">{</span>
        <span class="n">InputStreamReader</span> <span class="n">isr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
        <span class="n">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="n">isr</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
      <span class="o">}</span>
<span class="o">}</span>
</pre>


<h4>Height of B-Tree</h4>
<h5>Code</h5>
<p>This is my code from hankerrank.com:</p>
<pre class="code literal-block"><span></span>    <span class="cm">/*</span>
<span class="cm">    class Node</span>
<span class="cm">       int data;</span>
<span class="cm">       Node left;</span>
<span class="cm">       Node right;</span>
<span class="cm">    */</span>
   <span class="kt">int</span> <span class="nf">height</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">)</span>
    <span class="o">{</span>
         <span class="n">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
         <span class="k">if</span><span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
         <span class="o">}</span>
         <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">)&gt;</span><span class="n">height</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>
             <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">height</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
         <span class="k">else</span>
             <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">height</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
</pre>


<h4>Decide if B-Tree is Balanced</h4>
<p>Following method is taken from <a href="http://www.nowamagic.net/librarys/veda/detail/2314">this post</a>:</p>
<pre class="code literal-block"><span></span><span class="cm">/*</span>
<span class="cm">class Node</span>
<span class="cm">   int data;</span>
<span class="cm">   Node left;</span>
<span class="cm">   Node right;</span>
<span class="cm">*/</span>
<span class="c1">//Return depth of tree if tree is balanced. Otherwise return -1</span>
<span class="kt">int</span> <span class="nf">isBalenced</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">)</span>
<span class="o">{</span>
     <span class="n">Node</span> <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
     <span class="k">if</span><span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">//return 0 for null node</span>
     <span class="o">}</span>

     <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">isBalenced</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
     <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">isBalenced</span><span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>

     <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">left</span><span class="o">-</span><span class="n">right</span><span class="o">&lt;=</span><span class="mi">1</span> <span class="o">||</span> <span class="n">left</span><span class="o">-</span><span class="n">right</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span><span class="k">else</span><span class="o">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>
</div>
            </div>
        </div>
            <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="index.html" rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-7.html" rel="next">Older posts</a>
            </li>
        </ul></nav><script>var disqus_shortname="pengyinsnotes";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><footer id="footer"><p>Contents © 2016         <a href="mailto:shanpy901115@gmail.com">Pengyin Shan</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    </section><script src="assets/js/all-nocdn.js" type="text/javascript"></script><script type="text/javascript">
            $(function(){
                $('.timeago').timeago();
            });
        </script>
</body>
</html>
